var m=Object.defineProperty;var y=(n,e,t)=>e in n?m(n,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):n[e]=t;var a=(n,e,t)=>y(n,typeof e!="symbol"?e+"":e,t);const b="https://billtracker.kerosenelabs.com/api/v1".replace(/\/+$/,"");class f{constructor(e={}){this.configuration=e}set config(e){this.configuration=e}get basePath(){return this.configuration.basePath!=null?this.configuration.basePath:b}get fetchApi(){return this.configuration.fetchApi}get middleware(){return this.configuration.middleware||[]}get queryParamsStringify(){return this.configuration.queryParamsStringify||p}get username(){return this.configuration.username}get password(){return this.configuration.password}get apiKey(){const e=this.configuration.apiKey;if(e)return typeof e=="function"?e:()=>e}get accessToken(){const e=this.configuration.accessToken;if(e)return typeof e=="function"?e:async()=>e}get headers(){return this.configuration.headers}get credentials(){return this.configuration.credentials}}const A=new f,d=class d{constructor(e=A){a(this,"middleware");a(this,"fetchApi",async(e,t)=>{let r={url:e,init:t};for(const s of this.middleware)s.pre&&(r=await s.pre({fetch:this.fetchApi,...r})||r);let i;try{i=await(this.configuration.fetchApi||fetch)(r.url,r.init)}catch(s){for(const c of this.middleware)c.onError&&(i=await c.onError({fetch:this.fetchApi,url:r.url,init:r.init,error:s,response:i?i.clone():void 0})||i);if(i===void 0)throw s instanceof Error?new P(s,"The request failed and the interceptors did not return an alternative response"):s}for(const s of this.middleware)s.post&&(i=await s.post({fetch:this.fetchApi,url:r.url,init:r.init,response:i.clone()})||i);return i});this.configuration=e,this.middleware=e.middleware}withMiddleware(...e){const t=this.clone();return t.middleware=t.middleware.concat(...e),t}withPreMiddleware(...e){const t=e.map(r=>({pre:r}));return this.withMiddleware(...t)}withPostMiddleware(...e){const t=e.map(r=>({post:r}));return this.withMiddleware(...t)}isJsonMime(e){return e?d.jsonRegex.test(e):!1}async request(e,t){const{url:r,init:i}=await this.createFetchParams(e,t),s=await this.fetchApi(r,i);if(s&&s.status>=200&&s.status<300)return s;throw new j(s,"Response returned an error code")}async createFetchParams(e,t){let r=this.configuration.basePath+e.path;e.query!==void 0&&Object.keys(e.query).length!==0&&(r+="?"+this.configuration.queryParamsStringify(e.query));const i=Object.assign({},this.configuration.headers,e.headers);Object.keys(i).forEach(h=>i[h]===void 0?delete i[h]:{});const s=typeof t=="function"?t:async()=>t,c={method:e.method,headers:i,body:e.body,credentials:this.configuration.credentials},o={...c,...await s({init:c,context:e})};let u;E(o.body)||o.body instanceof URLSearchParams||R(o.body)?u=o.body:this.isJsonMime(i["Content-Type"])?u=JSON.stringify(o.body):u=o.body;const w={...o,body:u};return{url:r,init:w}}clone(){const e=this.constructor,t=new e(this.configuration);return t.middleware=this.middleware.slice(),t}};a(d,"jsonRegex",new RegExp("^(:?application/json|[^;/ 	]+/[^;/ 	]+[+]json)[ 	]*(:?;.*)?$","i"));let l=d;function R(n){return typeof Blob<"u"&&n instanceof Blob}function E(n){return typeof FormData<"u"&&n instanceof FormData}class j extends Error{constructor(t,r){super(r);a(this,"name","ResponseError");this.response=t}}class P extends Error{constructor(t,r){super(r);a(this,"name","FetchError");this.cause=t}}class q extends Error{constructor(t,r){super(r);a(this,"name","RequiredError");this.field=t}}function p(n,e=""){return Object.keys(n).map(t=>g(t,n[t],e)).filter(t=>t.length>0).join("&")}function g(n,e,t=""){const r=t+(t.length?`[${n}]`:n);if(e instanceof Array){const i=e.map(s=>encodeURIComponent(String(s))).join(`&${encodeURIComponent(r)}=`);return`${encodeURIComponent(r)}=${i}`}if(e instanceof Set){const i=Array.from(e);return g(n,i,t)}return e instanceof Date?`${encodeURIComponent(r)}=${encodeURIComponent(e.toISOString())}`:e instanceof Object?p(e,r):`${encodeURIComponent(r)}=${encodeURIComponent(String(e))}`}class C{constructor(e,t=r=>r){this.raw=e,this.transformer=t}async value(){return this.transformer(await this.raw.json())}}class ${constructor(e){this.raw=e}async value(){}}function F(){return new f({basePath:void 0})}function I(){const n=sessionStorage.getItem("jwt");if(!n)throw new Error("JWT not set, invalid session");return new f({basePath:void 0,headers:{Authorization:"Bearer "+n}})}async function M(n){if(n.response){const e=await n.response.json().catch(()=>null);return(e==null?void 0:e.message)||"An unexpected error occurred"}else return n.message||"A network error occurred"}export{l as B,C as J,q as R,$ as V,M as a,I as b,F as g};
